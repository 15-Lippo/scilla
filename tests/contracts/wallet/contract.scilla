import ListUtils IntUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library WalletLib

(* Event for communicating a new transaction id *)
let mk_transaction_added_event =
  fun (tc : Uint32) =>
    { _eventname : "Transaction created" ; transactionId : tc }

(* Event for communicating the signing of a transaction *)
let mk_transaction_signed_event =
  fun (no_of_sigs : Uint32) =>
    { _eventname : "Transaction signed" ; signature_count : no_of_sigs }

(* Error events *)
let mk_error_event =
  fun (err_msg : String) =>
    { _eventname : "WalletError" ; err_msg : err_msg }

(* Error messages *)
let non_owner_cannot_sign_err_msg   = "Signee not recognized as owner"
let unknown_transaction_id_err_msg  = "Unknown transaction id"
let insufficient_funds_err_msg      = "Insufficient funds in wallet"
let no_signature_list_found_err_msg = "No signature list for transaction"
let already_signed_err_msg          = "Transaction already signed by signee"
let invalid_contract_err_msg        = "Invalid contract"


let transaction_inc = Uint32 1
let empty_sigs = Emp ByStr20 Bool

let signature_added = Int32 3
let transaction_executed = Int32 2

(* Make map of owners *)
let mk_owners_map =
  fun (initial_owners : List ByStr20) =>
    let init = Emp ByStr20 Bool in
    let iter =
      fun (acc : Map ByStr20 Bool) =>
      fun (cur_owner : ByStr20) =>
        let mem = builtin get acc cur_owner in
        match mem with
        | Some True =>
          (* owner already added *)
          acc
        | _ =>
          (* owner not yet added, or removed *)
          let t = True in
          builtin put acc cur_owner t
        end in
    let folder = @list_foldl ByStr20 (Map ByStr20 Bool) in
    folder iter init initial_owners

(* Check that the number of distinct owners is greater than 0 *)
let check_contract_validity =
  fun (owners : Map ByStr20 Bool) =>
    let no_of_owners = builtin size owners in
    let zero = Uint32 0 in
    builtin lt zero no_of_owners

(* Create one transaction message *)
let transaction_msg =
  fun (recipient : ByStr20) =>
  fun (amount : Uint128) =>
    {_tag : Main; _recipient : recipient; _amount : amount;
     code : transaction_executed }

(* Wrap one transaction message as singleton list *)
let transaction_msgs =
  fun (recipient : ByStr20) =>
  fun (amount : Uint128) =>
    let one_msg = 
      fun (msg : Message) => 
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg in
    let msg = transaction_msg recipient amount in
    one_msg msg

(* list_mem for owners *)
let address_mem =
  fun (sender : ByStr20) =>
  fun (mem_map : Map ByStr20 Bool) =>
    let mem = builtin get mem_map sender in
    match mem with
    | None       => False
    | Some False => False
    | Some True  => True
    end

(* Create messages for executing waiting transactions *)
let execute_awaiting =
  fun (balance : Uint128) =>
  fun (awaiting : List (Pair ByStr20 Uint128)) =>
    (* Add transaction to list of unexecuted transactions *)
    let create_result_unexecuted =
      fun (balance : Uint128) =>
      fun (next_awaiting : Pair ByStr20 Uint128) =>
      fun (rest_awaiting : List (Pair ByStr20 Uint128)) =>
      fun (msgs : List Message) =>
        let new_awaiting = Cons {(Pair ByStr20 Uint128)} next_awaiting rest_awaiting in
        let msgs_awaiting = Pair {(List Message) (List (Pair ByStr20 Uint128))} msgs new_awaiting in
        Pair {Uint128 (Pair (List Message) (List (Pair ByStr20 Uint128)))} balance msgs_awaiting in
    (* Deduct remaining balance, and create execution message *)
    let create_result_executed =
      fun (balance : Uint128) =>
      fun (msgs : List Message) =>
        let new_awaiting = Nil {(Pair ByStr20 Uint128)} in
        let msgs_awaiting = Pair {(List Message) (List (Pair ByStr20 Uint128))} msgs new_awaiting in
        Pair {Uint128 (Pair (List Message) (List (Pair ByStr20 Uint128)))} balance msgs_awaiting in
    let folder = @list_foldl (Pair ByStr20 Uint128) (Pair Uint128 (Pair (List Message) (List (Pair ByStr20 Uint128)))) in
    (* Check if next awaiting transaction can be executed. *)
    (* If so, create message and reduce balance. *)
    (* Add to list of waiting transactions if not. *)
    let iter =
      fun (collected : Pair Uint128 (Pair (List Message) (List (Pair ByStr20 Uint128)))) =>
      fun (next_awaiting : Pair ByStr20 Uint128) =>
        match next_awaiting with
        | Pair recipient amount =>
          match collected with
          | Pair balance (Pair msgs awaiting) =>
            match awaiting with
            | Cons _ _ =>
              (* Earlier transactions still awaiting execution *)
              create_result_unexecuted balance next_awaiting awaiting msgs
            | Nil =>
              (* This is the earliest unexecuted transaction *)
              let not_enough_funds = builtin lt balance amount in
              match not_enough_funds with
              | True =>
                (* No more money *)
                create_result_unexecuted balance next_awaiting awaiting msgs
              | False =>
                (* Execute next transaction *)
                let new_balance = builtin sub balance amount in
                let msg = transaction_msg recipient amount in
                let new_msgs = Cons {Message} msg msgs in
                create_result_executed new_balance new_msgs
              end
            end
          end
        end in
    let empty_msgs = Nil {Message} in
    let init = create_result_executed balance empty_msgs in
    let tmp_res = folder iter init awaiting in
    (* No need to return remaining balance. *)
    match tmp_res with
    | Pair _ res => res
    end
      

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract Wallet
(
initial_owners      : List ByStr20,
required_signatures : Uint32
)

(* Funds are not allowed to be added if the contract is not valid *)
field validity_checked : Bool = False
field contract_valid   : Bool = False

(* adr -> True indicates that an owner *)
(* adr -> False or adr not in map indicates non-owner *)
(* The initial owners will be added as owners when funds are *)
(* initially added to the contract. *)
field owners           : Map ByStr20 Bool = Emp ByStr20 Bool

field transactionCount : Uint32 = Uint32 0
field signatures       : Map Uint32 (Map ByStr20 Bool) =
                           Emp Uint32 (Map ByStr20 Bool)
field transactions     : Map Uint32 (Pair ByStr20 Uint128) =
                           Emp Uint32 (Pair ByStr20 Uint128)
(* TODO: Add signees *)
field awaiting_funds   : List (Pair ByStr20 Uint128) = Nil {(Pair ByStr20 Uint128)}


(* Submit a transaction for future signoff *)
transition SubmitTransaction (recipient : ByStr20, amount : Uint128)
  tc <- transactionCount;

  (* Create new transaction *)
  transaction = Pair {ByStr20 Uint128} recipient amount;

  (* Add transaction to outstanding list of transactions *)
  ts_tmp <- transactions;
  ts_new = builtin put ts_tmp tc transaction;

  (* Add empty list of signatures *)
  sigs_tmp <- signatures;
  sigs_new = builtin put sigs_tmp tc empty_sigs;
  
  (* Increment transaction counter *)
  tc_new = builtin add tc transaction_inc;

  (* Update fields *)
  transactionCount := tc_new;
  transactions := ts_new;
  signatures := sigs_new;

  (* Create event with transaction Id *)
  e = mk_transaction_added_event tc;
  event e
end

(* Sign off on an existing transaction *)
transition SignTransaction (transactionId : Uint32)
  (* Helper function *)
  sender_mem = address_mem _sender;

  (* Only the owner is allowed to sign off transactions *)
  owners_tmp <- owners;
  sender_is_owner = sender_mem owners_tmp;
  match sender_is_owner with
  | False =>
    e = mk_error_event non_owner_cannot_sign_err_msg;
    event e
  | True =>
    (* Transaction must have been submitted *)
    ts_tmp <- transactions;
    transaction = builtin get ts_tmp transactionId;
    match transaction with
    | None =>
      e = mk_error_event unknown_transaction_id_err_msg;
      event e
    | Some (Pair recipient amount) =>
      (* Transaction must occur in signatures map *)
      sigs_tmp <- signatures;
      sigs_opt = builtin get sigs_tmp transactionId;
      match sigs_opt with
      | None =>
        e = mk_error_event no_signature_list_found_err_msg;
        event e
      | Some sigs =>
        (* Sender must not have signed already *)
        sender_has_signed = sender_mem sigs;
        match sender_has_signed with
        | True =>
          e = mk_error_event already_signed_err_msg;
          event e
        | False =>
          (* Signature is valid. Add to collected signatures *)
          t = True;
          new_sigs = builtin put sigs _sender t;
          new_signatures = builtin put sigs_tmp transactionId new_sigs;
          signatures := new_signatures;

          (* Check for sufficient number of signatures *)
          no_of_sigs = builtin size new_sigs;
          not_enough_signatures = builtin lt no_of_sigs required_signatures;
          match not_enough_signatures with
          | True =>
            (* Not enough signatures. Send message with id of created transaction *)
            e = mk_transaction_signed_event no_of_sigs;
            event e
          | False => 
            (* Enough signatures collected. Remove transaction and signatures *)
            new_ts = builtin remove ts_tmp transactionId;
            new_signatures = builtin remove new_signatures transactionId;
            transactions := new_ts;
            signatures := new_signatures;
            
            (* Check for sufficient funds  *)
            bal <- _balance;
            not_enough_money = builtin lt bal amount;
            match not_enough_money with
            | True =>
              (* Move transaction to back of list of waiting transactions *)
              await <- awaiting_funds;
              trans = Pair {ByStr20 Uint128} recipient amount;
              emp_trans_list = Nil {(Pair ByStr20 Uint128)};
              trans_as_list = Cons {(Pair ByStr20 Uint128)} trans emp_trans_list;
              new_await = let app = @list_append (Pair ByStr20 Uint128)
                          in app await trans_as_list;
              awaiting_funds := new_await;
              e = mk_error_event insufficient_funds_err_msg;
              event e
            | False =>
              (* Execute transaction. *)
              msgs = transaction_msgs recipient amount;
              send msgs
            end
          end
        end
      end
    end
  end
end




(* Revoke signature of existing transaction, if it has not yet been executed. *)
(* transition RevokeSignature () *)

(* Add new owner. Must be accepted by all existing owners *)
(* transition SignOffNewOwner (new_owner : ByStr20) *)
  


(* Add funds to wallet *)
transition AddFunds ()
  (* Only accept funds if number of required signatures is less than the number of distinct owners *)
  checked <- validity_checked;
  match checked with
  | False =>
    owners_map = mk_owners_map initial_owners;
    owners := owners_map;
    valid_contract = check_contract_validity owners_map;
    contract_valid := valid_contract;
    checked = True;
    validity_checked := checked
  | True =>
    valid <- contract_valid
  end;

  valid <- contract_valid;
  match valid with
  | False =>
    e = mk_error_event invalid_contract_err_msg;
    event e
  | True =>
    accept;
    (* Execute awaiting transactions *)
    bal <- _balance;
    await_tmp <- awaiting_funds;
    execute_result = execute_awaiting bal await_tmp;
    match execute_result with
    | Pair msgs await =>
      awaiting_funds := await;
      send msgs
    end
  end
end