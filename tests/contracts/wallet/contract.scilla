import ListUtils IntUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library WalletLib

let transaction_inc = Uint32 1
let empty_sigs = Nil {ByStr20}

let signature_added = Int32 3
let transaction_executed = Int32 2

let check_contract_validity =
  fun (owners : List ByStr20) =>
  fun (required_signatures : Int32) =>
    let find = @list_find ByStr20 in
    let len = @list_length ByStr20 in
    let finder =
      fun (cur_owner : ByStr20) =>
      fun (seen_owners : List ByStr20) =>
        let cur_owner_eq =
          fun (other : ByStr20) => builtin eq cur_owner other in
        find cur_owner_eq seen_owners in
    let folder = @list_foldl ByStr20 (List ByStr20) in
    let init = Nil {ByStr20} in
    let iter =
      fun (seen_owners : List ByStr20) =>
      fun (cur_owner : ByStr20) =>
        let found = finder cur_owner seen_owners in
        match found with
        | Some _ => seen_owners
        | None => Cons {ByStr20} cur_owner seen_owners
        end in
    let filtered_owners = folder iter init owners in
    let no_of_filtered_owners = len filtered_owners in
    int32_le required_signatures no_of_filtered_owners
         
let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let transaction_msg =
  fun (recipient : ByStr20) =>
  fun (amount : Uint128) =>
    {_tag : Main; _recipient : recipient; _amount : amount;
     code : transaction_executed }
  
let transaction_msgs =
  fun (recipient : ByStr20) =>
  fun (amount : Uint128) =>
    let msg = transaction_msg recipient amount in
    let msgs = one_msg msg in
    msgs

let address_mem =
  fun (sender : ByStr20) =>
  fun (mem_list : List ByStr20) =>
    let predicate =
      fun (m1 : ByStr20) =>
      fun (m2 : ByStr20) =>
        builtin eq m1 m2 in
        let mem = @list_mem ByStr20 in
        mem predicate sender mem_list

let execute_awaiting =
  fun (balance : Uint128) =>
  fun (awaiting : List (Pair ByStr20 Uint128)) =>
    let create_result_unexecuted =
      fun (balance : Uint128) =>
      fun (next_awaiting : Pair ByStr20 Uint128) =>
      fun (rest_awaiting : List (Pair ByStr20 Uint128)) =>
      fun (msgs : List Message) =>
        let new_awaiting = Cons {(Pair ByStr20 Uint128)} next_awaiting rest_awaiting in
        let msgs_awaiting = Pair {(List Message) (List (Pair ByStr20 Uint128))} msgs new_awaiting in
        Pair {Uint128 (Pair (List Message) (List (Pair ByStr20 Uint128)))} balance msgs_awaiting in
    let create_result_executed =
      fun (balance : Uint128) =>
      fun (msgs : List Message) =>
        let new_awaiting = Nil {(Pair ByStr20 Uint128)} in
        let msgs_awaiting = Pair {(List Message) (List (Pair ByStr20 Uint128))} msgs new_awaiting in
        Pair {Uint128 (Pair (List Message) (List (Pair ByStr20 Uint128)))} balance msgs_awaiting in
    let folder = @list_foldl (Pair ByStr20 Uint128) (Pair Uint128 (Pair (List Message) (List (Pair ByStr20 Uint128)))) in
    let iter =
      fun (collected : Pair Uint128 (Pair (List Message) (List (Pair ByStr20 Uint128)))) =>
      fun (next_awaiting : Pair ByStr20 Uint128) =>
        match next_awaiting with
        | Pair recipient amount =>
          match collected with
          | Pair balance (Pair msgs awaiting) =>
            match awaiting with
            | Cons _ _ =>
              (* Earlier transactions still awaiting execution *)
              create_result_unexecuted balance next_awaiting awaiting msgs
            | Nil =>
              (* This is the earliest unexecuted transaction *)
              let not_enough_funds = builtin lt balance amount in
              match not_enough_funds with
              | True =>
                (* No more money *)
                create_result_unexecuted balance next_awaiting awaiting msgs
              | False =>
                (* Execute next transaction *)
                let new_balance = builtin sub balance amount in
                let msg = transaction_msg recipient amount in
                let new_msgs = Cons {Message} msg msgs in
                create_result_executed new_balance new_msgs
              end
            end
          end
        end in
    let empty_msgs = Nil {Message} in
    let init = create_result_executed balance empty_msgs in
    let tmp_res = folder iter init awaiting in
    match tmp_res with
    | Pair _ res => res
    end
      

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract Wallet
(
owners              : List ByStr20,
required_signatures : Int32
)

(* Funds are not allowed to be added if the contract is not valid *)
field validity_checked : Bool = False
field contract_valid   : Bool = False

field transactionCount : Uint32 = Uint32 0
field signatures       : Map Uint32 (List ByStr20) =
                           Emp Uint32 (List ByStr20)
field transactions     : Map Uint32 (Pair ByStr20 Uint128) =
                           Emp Uint32 (Pair ByStr20 Uint128)
field awaiting_funds   : List (Pair ByStr20 Uint128) = Nil {(Pair ByStr20 Uint128)}

(* Submit a transaction for future signoff *)
transition SubmitTransaction (recipient : ByStr20, amount : Uint128)
  tc <- transactionCount;

  (* Create new transaction *)
  transaction = Pair {ByStr20 Uint128} recipient amount;

  (* Add transaction to outstanding list of transactions *)
  ts_tmp <- transactions;
  ts_new = builtin put ts_tmp tc transaction;

  (* Add empty list of signatures *)
  sigs_tmp <- signatures;
  sigs_new = builtin put sigs_tmp tc empty_sigs;
  
  (* Increment transaction counter *)
  tc_new = builtin add tc transaction_inc;

  (* Update fields *)
  transactionCount := tc_new;
  transactions := ts_new;
  signatures := sigs_new;

  (* Create event with transaction Id *)
  e = { _eventname : "Transaction created" ; transactionId : tc };
  event e
end

(* Sign off on an existing transaction *)
transition SignTransaction (transactionId : Uint32)
  (* Helper function *)
  sender_mem = address_mem _sender;

  (* Only the owner is allowed to sign off transactions *)
  sender_is_owner = sender_mem owners;
  match sender_is_owner with
  | False =>
    e = { _eventname : "Signee not recognized as owner" };
    event e
  | True =>
    (* Transaction must have been submitted *)
    ts_tmp <- transactions;
    transaction = builtin get ts_tmp transactionId;
    match transaction with
    | None =>
      e = { _eventname : "Unknown transaction id" };
      event e
    | Some (Pair recipient amount) =>
      (* Transaction must occur in signatures map *)
      sigs_tmp <- signatures;
      sigs_opt = builtin get sigs_tmp transactionId;
      match sigs_opt with
      | None =>
        e = { _eventname : "No signature list for transaction" };
        event e
      | Some sigs =>
        (* Sender must not have signed already *)
        sender_has_signed = sender_mem sigs;
        match sender_has_signed with
        | True =>
          e = { _eventname : "Transaction already signed by signee" };
          event e
        | False =>
          (* Signature is valid. Add to collected signatures *)
          new_sigs = Cons {ByStr20} _sender sigs;
          new_signatures = builtin put sigs_tmp transactionId new_sigs;
          signatures := new_signatures;

          (* Check for sufficient number of signatures *)
          len = @list_length ByStr20;
          no_of_sigs = len new_sigs;
          not_enough_signatures = builtin lt no_of_sigs required_signatures;
          match not_enough_signatures with
          | True =>
            (* Not enough signatures. Send message with id of created transaction *)
            msg = {_tag : Main; _recipient : recipient; _amount : Uint128 0;
                   code : signature_added; number_of_signatures : no_of_sigs };
            msgs = one_msg msg;
            send msgs
          | False => 
            (* Enough signatures collected. Remove transaction and signatures *)
            new_ts = builtin remove ts_tmp transactionId;
            new_signatures = builtin remove new_signatures transactionId;
            transactions := new_ts;
            signatures := new_signatures;
            
            (* Check for sufficient funds  *)
            bal <- _balance;
            not_enough_money = builtin lt bal amount;
            match not_enough_money with
            | True =>
              (* Move transaction to back of list of waiting transactions *)
              await <- awaiting_funds;
              trans = Pair {ByStr20 Uint128} recipient amount;
              emp_trans_list = Nil {(Pair ByStr20 Uint128)};
              trans_as_list = Cons {(Pair ByStr20 Uint128)} trans emp_trans_list;
              new_await = let app = @list_append (Pair ByStr20 Uint128)
                          in app await trans_as_list;
              awaiting_funds := new_await;

              e = { _eventname : "Insufficient funds in wallet" };
              event e
            | False =>
              (* Execute transaction. *)
              msgs = transaction_msgs recipient amount;
              send msgs
            end
          end
        end
      end
    end
  end
end

(* Add funds to wallet *)
transition AddFunds ()
  (* Only accept funds if number of required signatures is less than the number of distinct owners *)
  checked <- validity_checked;
  match checked with
  | False =>
    valid_contract = check_contract_validity owners required_signatures;
    contract_valid := valid_contract;
    checked = True;
    validity_checked := checked
  | True =>
    valid <- contract_valid
  end;

  valid <- contract_valid;
  match valid with
  | False =>
    e = { _eventname : "Invalid contract" };
    event e
  | True =>
    accept;
    (* Execute awaiting transactions *)
    bal <- _balance;
    await_tmp <- awaiting_funds;
    execute_result = execute_awaiting bal await_tmp;
    match execute_result with
    | Pair msgs await =>
      awaiting_funds := await;
      send msgs
    end
  end
end