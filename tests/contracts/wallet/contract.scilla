import ListUtils IntUtils BoolUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library WalletLib

(* Event for communicating a new transaction id *)
let mk_transaction_added_event =
  fun (tc : Uint32) =>
    { _eventname : "Transaction created" ; transactionId : tc }

(* Event for communicating the signing of a transaction *)
let mk_transaction_signed_event =
  fun (no_of_sigs : Uint32) =>
    { _eventname : "Transaction signed" ; signature_count : no_of_sigs }

(* Event for communicating a the addition of a new owner *)
let mk_candidate_owner_added_event =
    { _eventname : "Candiate owner added" }

(* Event for communicating a the signing off of a new owner *)
let mk_owner_signed_event =
  fun (no_of_sigs : Uint32) =>
    { _eventname : "Owner signed" ; signature_count : no_of_sigs }

(* Event for communicating a the addition of a new owner *)
let mk_new_owner_approved_event =
    { _eventname : "New owner approved" }

(* Error events *)
let mk_error_event =
  fun (err_msg : String) =>
    { _eventname : "WalletError" ; err_msg : err_msg }

(* Error messages *)
let non_owner_cannot_sign_err_msg   = "Signee not recognized as owner"
let unknown_transaction_id_err_msg  = "Unknown transaction id"
let insufficient_funds_err_msg      = "Insufficient funds in wallet"
let no_signature_list_found_err_msg = "No signature list found"
let already_signed_err_msg          = "Transaction already signed by signee"
let not_already_signed_err_msg      = "Transaction not signed by signee"
let invalid_contract_err_msg        = "Invalid contract"
let invalid_amount_err_msg          = "Invalid amount"


let transaction_inc = Uint32 1
let empty_sigs = Emp ByStr20 Bool

let signature_added = Int32 3
let transaction_executed = Int32 2

(* Make map of owners *)
let mk_owners_map =
  fun (initial_owners : List ByStr20) =>
    let init = Emp ByStr20 Bool in
    let iter =
      fun (acc : Map ByStr20 Bool) =>
      fun (cur_owner : ByStr20) =>
        let mem = builtin get acc cur_owner in
        match mem with
        | Some True =>
          (* owner already added *)
          acc
        | _ =>
          (* owner not yet added, or removed *)
          let t = True in
          builtin put acc cur_owner t
        end in
    let folder = @list_foldl ByStr20 (Map ByStr20 Bool) in
    folder iter init initial_owners

(* Check that the number of distinct owners is greater than 0 *)
let check_contract_validity =
  fun (owners : Map ByStr20 Bool) =>
    let no_of_owners = builtin size owners in
    let zero = Uint32 0 in
    builtin lt zero no_of_owners

(* Create one transaction message *)
let transaction_msg =
  fun (recipient : ByStr20) =>
  fun (amount : Uint128) =>
    {_tag : Main; _recipient : recipient; _amount : amount;
     code : transaction_executed }

(* Wrap one transaction message as singleton list *)
let transaction_msg_as_list =
  fun (recipient : ByStr20) =>
  fun (amount : Uint128) =>
    let one_msg = 
      fun (msg : Message) => 
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg in
    let msg = transaction_msg recipient amount in
    one_msg msg

(* Create messages for list of transactions *)
let transaction_msgs =
  fun (transaction_ids : List Uint32) =>
  fun (transactions : Map Uint32 (Pair ByStr20 Uint128)) =>
    let mapper = @list_map Uint32 Message in
    let iter =
      fun (id : Uint32) =>
        let transaction = builtin get transactions id in
        match transaction with
        | None =>
          (* Should not happen *)
          let dummy_amount = Uint128 0 in
          let dummy_address = 0x0000000000000000000000000000000000000000 in
          transaction_msg dummy_address dummy_amount
        | Some (Pair recipient amount) =>
          transaction_msg recipient amount
        end in
    mapper iter transaction_ids

(* list_mem for owners *)
let address_mem =
  fun (sender : ByStr20) =>
  fun (mem_map : Map ByStr20 Bool) =>
    let mem = builtin get mem_map sender in
    match mem with
    | None       => False
    | Some False => False
    | Some True  => True
    end

(* Split awaiting transactions into list of ones we can afford and list of ones we cannot *)
let get_affordable_awaiting =
  fun (balance : Uint128) =>
  fun (awaiting : List Uint32) =>
  fun (transactions : Map Uint32 (Pair ByStr20 Uint128)) =>
    let folder = @list_foldr Uint32 (Pair Uint128 (Pair (List Uint32) (List Uint32))) in
    let iter =
      fun (next_awaiting : Uint32) =>
      fun (acc : Pair Uint128 (Pair (List Uint32) (List Uint32))) =>
        match acc with
        | Pair remaining_balance (Pair to_be_executed not_to_be_executed) =>
          let transaction = builtin get transactions next_awaiting in
          match transaction with
          | None =>
            (* Transaction should exist, but we can't fix it here, so just ignore. *)
            acc
          | Some (Pair recipient amount) =>
            let not_enough_funds = builtin lt remaining_balance amount in
            match not_enough_funds with
            | True =>
              (* Not enough money *)
              let new_not_to_be_executed = Cons {Uint32} next_awaiting not_to_be_executed in
              let awaiting_pair = Pair {(List Uint32) (List Uint32)} to_be_executed new_not_to_be_executed in
              Pair {Uint128 (Pair (List Uint32) (List Uint32))} balance awaiting_pair
            | False =>
              (* To be executed *)
              let new_to_be_executed = Cons {Uint32} next_awaiting to_be_executed in
              let awaiting_pair = Pair {(List Uint32) (List Uint32)} new_to_be_executed not_to_be_executed in
              let new_remaining_balance = builtin sub balance amount in
              Pair {Uint128 (Pair (List Uint32) (List Uint32))} new_remaining_balance awaiting_pair
            end
          end
        end in
    let empty_awaiting = Nil {Uint32} in
    let init_awaiting_pair = Pair {(List Uint32) (List Uint32)} empty_awaiting empty_awaiting in
    let init = Pair {Uint128 (Pair (List Uint32) (List Uint32))} balance init_awaiting_pair in
    folder iter init awaiting

(* Remove list of keys from map *)
let remove_keys =
  tfun 'K =>
  tfun 'V =>
  fun (map : Map 'K 'V) =>
  fun (keys : List 'K) =>
    let folder = @list_foldl 'K (Map 'K 'V) in
    let iter =
      fun (acc : Map 'K 'V) =>
      fun (next_key : 'K) =>
        builtin remove acc next_key in
    folder iter map keys

(* Remove transaction id from list *)
let remove_transaction_id =
  fun (element : Uint32) =>
  fun (l : List Uint32) =>
    let filterer = @list_filter Uint32 in
    let pred =
      fun (e : Uint32) =>
        let equal = uint32_eq e element in
        negb equal in
    filterer pred l
        

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract Wallet
(
initial_owners      : List ByStr20,
required_signatures : Uint32
)

(* Funds are not allowed to be added if the contract is not valid *)
field validity_checked : Bool = False
field contract_valid   : Bool = False

(* adr -> True indicates that an owner *)
(* adr not in map indicates non-owner *)
(* adr -> False is not used *)
(* The initial owners will be added as owners when funds are *)
(* initially added to the contract. *)
field owners           : Map ByStr20 Bool = Emp ByStr20 Bool

field transactionCount : Uint32 = Uint32 0

(* Collected signatures for transactions *)
field signatures       : Map Uint32 (Map ByStr20 Bool) =
                           Emp Uint32 (Map ByStr20 Bool)
(* Awaiting transactions *) 
field transactions     : Map Uint32 (Pair ByStr20 Uint128) =
                           Emp Uint32 (Pair ByStr20 Uint128)
(* Approved transactions awaiting funds *) 
field awaiting_funds   : List Uint32 = Nil {Uint32}

(* Collected signatures for new owners *)
field owner_signatures : Map ByStr20 (Map ByStr20 Bool) =
                           Emp ByStr20 (Map ByStr20 Bool)


(* Submit a transaction for future signoff *)
transition SubmitTransaction (recipient : ByStr20, amount : Uint128)
  tc <- transactionCount;

  zero = Uint128 0;
  amount_is_zero = builtin eq amount zero;

  match amount_is_zero with
  | True =>
    (* Illegal transaction *)
    e = mk_error_event invalid_amount_err_msg;
    event e
  | False =>
    (* Create new transaction *)
    transaction = Pair {ByStr20 Uint128} recipient amount;
    
    (* Add transaction to outstanding list of transactions *)
    ts_tmp <- transactions;
    ts_new = builtin put ts_tmp tc transaction;
    
    (* Add empty list of signatures *)
    sigs_tmp <- signatures;
    sigs_new = builtin put sigs_tmp tc empty_sigs;
    
    (* Increment transaction counter *)
    tc_new = builtin add tc transaction_inc;
    
    (* Update fields *)
    transactionCount := tc_new;
    transactions := ts_new;
    signatures := sigs_new;
    
    (* Create event with transaction Id *)
    e = mk_transaction_added_event tc;
    event e
  end
end

(* Sign off on an existing transaction *)
transition SignTransaction (transactionId : Uint32)
  (* Helper function *)
  sender_mem = address_mem _sender;

  (* Only the owner is allowed to sign off transactions *)
  owners_tmp <- owners;
  sender_is_owner = sender_mem owners_tmp;
  match sender_is_owner with
  | False =>
    e = mk_error_event non_owner_cannot_sign_err_msg;
    event e
  | True =>
    (* Transaction must have been submitted *)
    ts_tmp <- transactions;
    transaction = builtin get ts_tmp transactionId;
    match transaction with
    | None =>
      e = mk_error_event unknown_transaction_id_err_msg;
      event e
    | Some (Pair recipient amount) =>
      (* Transaction must occur in signatures map *)
      sigs_tmp <- signatures;
      sigs_opt = builtin get sigs_tmp transactionId;
      match sigs_opt with
      | None =>
        e = mk_error_event no_signature_list_found_err_msg;
        event e
      | Some sigs =>
        (* Sender must not have signed already *)
        sender_has_signed = sender_mem sigs;
        match sender_has_signed with
        | True =>
          e = mk_error_event already_signed_err_msg;
          event e
        | False =>
          (* Signature is valid. Add to collected signatures *)
          t = True;
          new_sigs = builtin put sigs _sender t;
          new_signatures = builtin put sigs_tmp transactionId new_sigs;
          signatures := new_signatures;

          (* Check for sufficient number of signatures *)
          no_of_sigs = builtin size new_sigs;
          not_enough_signatures = builtin lt no_of_sigs required_signatures;
          match not_enough_signatures with
          | True =>
            (* Not enough signatures. Send message with id of created transaction *)
            e = mk_transaction_signed_event no_of_sigs;
            event e
          | False => 
            (* Check for sufficient funds  *)
            bal <- _balance;
            not_enough_money = builtin lt bal amount;
            match not_enough_money with
            | True =>
              (* Add transaction to list of waiting transactions *)
              await <- awaiting_funds;
              new_await = Cons {Uint32} transactionId await;
              awaiting_funds := new_await;
              e = mk_error_event insufficient_funds_err_msg;
              event e
            | False =>
              (* Enough signatures collected, and enough money available. *)
              (* Remove transaction and signatures, and execute. *)
              new_ts = builtin remove ts_tmp transactionId;
              new_signatures = builtin remove new_signatures transactionId;
              transactions := new_ts;
              signatures := new_signatures;
              (* Execute transaction. *)
              msgs = transaction_msg_as_list recipient amount;
              send msgs
            end
          end
        end
      end
    end
  end
end

(* Revoke signature of existing transaction, if it has not yet been executed. *)
transition RevokeSignature (transactionId : Uint32)
  (* Transaction must occur in signatures map *)
  sigs_tmp <- signatures;
  sigs_opt = builtin get sigs_tmp transactionId;
  match sigs_opt with
  | None =>
    e = mk_error_event no_signature_list_found_err_msg;
    event e
  | Some sigs =>
    (* Sender must have signed already *)
    sender_has_signed = address_mem _sender sigs;
    match sender_has_signed with
    | False =>
      e = mk_error_event not_already_signed_err_msg;
      event e
    | True =>
      new_sigs = builtin remove sigs _sender;
      new_signatures = builtin put sigs_tmp transactionId new_sigs;
      signatures := new_signatures;
      (* Check if this invalidates transaction *)
      old_no_of_sigs = builtin size sigs;
      new_no_of_sigs = builtin size new_sigs;
      was_approved = uint32_ge old_no_of_sigs required_signatures;
      no_longer_approved = uint32_lt new_no_of_sigs required_signatures;
      must_remove_from_awaiting = andb was_approved no_longer_approved;
      match must_remove_from_awaiting with
      | False =>
      | True =>
        await_tmp <- awaiting_funds;
        new_await = remove_transaction_id transactionId await_tmp;
        awaiting_funds := new_await
      end
    end
  end
end

(* Revoke signature for new owner *)
transition RevokeOwnerSignature (new_owner : ByStr20)
  (* new owner must occur in signatures map *)
  sigs_tmp <- owner_signatures;
  sigs_opt = builtin get sigs_tmp new_owner;
  match sigs_opt with
  | None =>
    e = mk_error_event no_signature_list_found_err_msg;
    event e
  | Some sigs =>
    (* Sender must have signed already *)
    sender_has_signed = address_mem _sender sigs;
    match sender_has_signed with
    | False =>
      e = mk_error_event not_already_signed_err_msg;
      event e
    | True =>
      new_sigs = builtin remove sigs _sender;
      new_signatures = builtin put sigs_tmp new_owner new_sigs;
      owner_signatures := new_signatures
    end
  end
end

(* Sign off on new owner. *)
transition SignOffNewOwner (new_owner : ByStr20)
  (* Helpers *)
  sender_mem = address_mem _sender;
  t = True;

  (* Only owners are allowed to sign off new owners *)
  owners_tmp <- owners;
  sender_is_owner = sender_mem owners_tmp;
  match sender_is_owner with
  | False =>
    e = mk_error_event non_owner_cannot_sign_err_msg;
    event e
  | True =>
    owner_signatures_tmp <- owner_signatures;
    sigs_option = builtin get owner_signatures_tmp new_owner;
    match sigs_option with
    | None =>
      (* New owner *)
      empty_sigs = Emp ByStr20 Bool;
      new_sigs = builtin put empty_sigs _sender t;
      new_owner_signatures = builtin put owner_signatures_tmp new_owner new_sigs;
      owner_signatures := new_owner_signatures;
      (* Create event with owner id *)
      e = mk_candidate_owner_added_event;
      event e
    | Some sigs =>
      (* Sender must not have signed already *)
      sender_has_signed = sender_mem sigs;
      match sender_has_signed with
      | True =>
        e = mk_error_event already_signed_err_msg;
        event e
      | False =>
        new_sigs = builtin put sigs _sender t;
        new_owner_signatures = builtin put owner_signatures_tmp new_owner new_sigs;
        owner_signatures := new_owner_signatures;
        (* Create event with owner id *)
        no_of_sigs = builtin size new_sigs;
        e = mk_owner_signed_event no_of_sigs;
        event e
      end
    end;
    (* Check if all owners have signed *)
    current_owners <- owners;
    owner_signatures_tmp <- owner_signatures;
    sigs_option = builtin get owner_signatures_tmp new_owner;
    match sigs_option with
    | None =>
      (* Cannot happen *)
    | Some sigs => 
      no_of_owners = builtin size current_owners;
      no_of_sigs = builtin size sigs;
      all_have_signed = uint32_eq no_of_sigs no_of_owners;
      match all_have_signed with
      | False =>
      | True =>
        new_owner_signatures = builtin remove owner_signatures_tmp new_owner;
        owner_signatures := new_owner_signatures;
        new_owners = builtin put current_owners new_owner t;
        owners := new_owners;
        (* Create event with owner id *)
        e = mk_new_owner_approved_event;
        event e
      end
    end
  end  
end


(* Add funds to wallet *)
transition AddFunds ()
  (* Only accept funds if number of required signatures is less than the number of distinct owners *)
  checked <- validity_checked;
  match checked with
  | False =>
    owners_map = mk_owners_map initial_owners;
    owners := owners_map;
    valid_contract = check_contract_validity owners_map;
    contract_valid := valid_contract;
    checked = True;
    validity_checked := checked
  | True =>
  end;

  valid <- contract_valid;
  match valid with
  | False =>
    e = mk_error_event invalid_contract_err_msg;
    event e
  | True =>
    accept;
    (* Execute awaiting transactions *)
    bal <- _balance;
    await_tmp <- awaiting_funds;
    trans <- transactions;
    sigs <- signatures;
    
    split_awaiting = get_affordable_awaiting bal await_tmp trans;
    match split_awaiting with
    | Pair _ (Pair to_be_executed not_to_be_executed) =>
      (* Generate messages *)
      msgs = transaction_msgs to_be_executed trans;
      (* Remove executed transactions *)
      transaction_remover = @remove_keys Uint32 (Pair ByStr20 Uint128);
      signature_remover = @remove_keys Uint32 (Map ByStr20 Bool);
      new_transactions = transaction_remover trans to_be_executed;
      awaiting_funds := not_to_be_executed;
      transactions := new_transactions;
      new_signatures = signature_remover sigs to_be_executed;
      signatures := new_signatures;
      (* Execute transactions *)
      send msgs
    end 
  end
end
